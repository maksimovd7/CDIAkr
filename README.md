Тема 3.1-3.5. Алгоритмы. Работа в онлайн-IDE jdoodle.com с алгоритмами сортировки и
поиска (проводится в виде итоговой контрольной работы по разделу 3 РПД).

1)Блочная (корзинная) сортировка

Определение:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
2. Каждый элемент помещается в корзину согласно функции распределения.
3. Содержимое каждой корзины сортируется индивидуально.
4. Корзины соединяются в порядке увеличения диапазона.

 Временная сложность: 
O(n²)

Обоснование:
Распределение n элементов по k корзинам: O(n)
Сортировка каждой корзины: в среднем O(n/k) на корзину при равномерном распределении


2)Блинная сортировка
Определение:
Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.

Принцип работы:
Находим позицию максимального элемента в несортированной части
Переворачимаем массив до этой позиции, чтобы максимум оказался в начале
Переворачиваем всю несортированную часть, ставя максимум на правильную позицию
Повторяем для оставшейся несортированной части

Временная сложность: 
O(n²)

Обоснование:
Внешний цикл выполняется n раз
Поиск максимума в несортированной части: O(n)
Каждая операция переворота (flip): O(n)
Итого: O(n) × O(n) = O(n²)

3)Сортировка бусинами (гравитационная)
Определение: 
Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Принцип работы:
Представляем числа как ряды бусин на вертикальных стержнях
"Включаем гравитацию" - бусины падают вниз
После падения количество бусин на каждом стержне соответствует отсортированному числу
Считываем результат снизу вверх

Временная сложность: 
O(S), где S - сумма всех элементов массива

Обоснование:
Время работы пропорционально общему количеству "бусин"
Каждая операция с бусиной требует O(1) времени
В худшем случае O(n × m), где m - максимальное значение элемента

4)Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Принцип работы:
Прыгаем вперед с фиксированным шагом (обычно √n)
Когда находим элемент больше искомого, останавливаемся
Возвращаемся к предыдущей позиции и выполняем линейный поиск в этом блоке
Находим элемент или убеждаемся в его отсутствии

Временная сложность: 
O(√n)

Обоснование:
Оптимальный размер прыжка: √n
Количество прыжков: O(n/√n) = O(√n)
Линейный поиск в блоке размером √n: O(√n)
Итого: O(√n) + O(√n) = O(√n)

5)Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне

Принцип работы:
Начинаем с первого элемента
Удваиваем границу поиска пока не найдем диапазон, содержащий искомый элемент
В найденном диапазоне выполняем бинарный поиск
Особенно эффективен для неограниченных массивов

Временная сложность: 
O(log n)

Обоснование:
Экспоненциальное увеличение границы поиска: O(log n) шагов
Бинарный поиск в найденном диапазоне: O(log n)
Итого: O(log n) + O(log n) = O(log n)

6)Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Принцип работы:
Делим отсортированный массив на три равные части
Сравниваем искомый элемент с граничными значениями
Определяем, в какой трети находится элемент
Рекурсивно повторяем для выбранной трети
Работает только для унимодальных функций

Временная сложность:
O(log₃n)

Обоснование:
На каждой итерации поисковое пространство уменьшается в 3 раза
Количество итераций: log₃n
На каждой итерации выполняется O(1) операций сравнения
В асимптотике: O(log₃n) = O(log n)
