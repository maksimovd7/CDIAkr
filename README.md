Тема 3.1-3.5. Алгоритмы. Работа в онлайн-IDE jdoodle.com с алгоритмами сортировки и
поиска (проводится в виде итоговой контрольной работы по разделу 3 РПД).

1)Блочная (корзинная) сортировка

Определение:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
2. Каждый элемент помещается в корзину согласно функции распределения.
3. Содержимое каждой корзины сортируется индивидуально.
4. Корзины соединяются в порядке увеличения диапазона.

 Временная сложность: 
O(n²)

Обоснование:
Распределение n элементов по k корзинам: O(n)
Сортировка каждой корзины: в среднем O(n/k) на корзину при равномерном распределении

Результат работы:
Входные данные: [0.9162826228685323, 0.23611533881653013, 0.4406410733783044, 0.408382143641579, 0.11291882867337522, 0.0033944906232625804, 0.9301901132221059, 0.16380363873840198, 0.6866074668174142, 0.29901029132013957, 0.4911535618332046, 0.7096263216786441, 0.9988418007283508, 0.09496060429618425, 0.5063499038998936, 0.2788081351632986, 0.48315510164729647, 0.9735754288135086, 0.5921096032228879, 0.9583565581821408]

Отсортированные данные: [0.0033944906232625804, 0.09496060429618425, 0.11291882867337522, 0.16380363873840198, 0.23611533881653013, 0.2788081351632986, 0.29901029132013957, 0.408382143641579, 0.4406410733783044, 0.48315510164729647, 0.4911535618332046, 0.5063499038998936, 0.5921096032228879, 0.6866074668174142, 0.7096263216786441, 0.9162826228685323, 0.9301901132221059, 0.9583565581821408, 0.9735754288135086, 0.9988418007283508]




2)Блинная сортировка
Определение:
Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.

Принцип работы:
Находим позицию максимального элемента в несортированной части
Переворачимаем массив до этой позиции, чтобы максимум оказался в начале
Переворачиваем всю несортированную часть, ставя максимум на правильную позицию
Повторяем для оставшейся несортированной части

Временная сложность: 
O(n²)

Обоснование:
Внешний цикл выполняется n раз
Поиск максимума в несортированной части: O(n)
Каждая операция переворота (flip): O(n)
Итого: O(n) × O(n) = O(n²)

Результат работы:
Входные данные для блинной сортировки: [5, 46, 54, 86, 14, 88, 82, 4, 24, 82, 58, 21, 16, 44, 58]
Отсортированные данные блинной сортировкой: [4, 5, 14, 16, 21, 24, 44, 46, 54, 58, 58, 82, 82, 86, 88]



3)Сортировка бусинами (гравитационная)
Определение: 
Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Принцип работы:
Представляем числа как ряды бусин на вертикальных стержнях
"Включаем гравитацию" - бусины падают вниз
После падения количество бусин на каждом стержне соответствует отсортированному числу
Считываем результат снизу вверх

Временная сложность: 
O(S), где S - сумма всех элементов массива

Обоснование:
Время работы пропорционально общему количеству "бусин"
Каждая операция с бусиной требует O(1) времени
В худшем случае O(n × m), где m - максимальное значение элемента

Результат работы:
Входные данные для сортировки бусинами: [29, 38, 41, 44, 32, 27, 42, 29, 19, 35, 41, 47, 28, 10, 38]
Отсортированные данные бусинами сортировкой: [10, 19, 27, 28, 29, 29, 32, 35, 38, 38, 41, 41, 42, 44, 47]



4)Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Принцип работы:
Прыгаем вперед с фиксированным шагом (обычно √n)
Когда находим элемент больше искомого, останавливаемся
Возвращаемся к предыдущей позиции и выполняем линейный поиск в этом блоке
Находим элемент или убеждаемся в его отсутствии

Временная сложность: 
O(√n)

Обоснование:
Оптимальный размер прыжка: √n
Количество прыжков: O(n/√n) = O(√n)
Линейный поиск в блоке размером √n: O(√n)
Итого: O(√n) + O(√n) = O(√n)

Результат работы: 
Отсортированные входные данные: [5, 8, 11, 12, 15, 17, 23, 30, 33, 39, 40, 42, 45, 47, 49, 51, 55, 58, 61, 64, 65, 69, 84, 86, 89, 90, 91, 93, 97, 99]
Искомый элемент: 84
Элемент 84 найден на индексе: 22



5)Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне

Принцип работы:
Начинаем с первого элемента
Удваиваем границу поиска пока не найдем диапазон, содержащий искомый элемент
В найденном диапазоне выполняем бинарный поиск
Особенно эффективен для неограниченных массивов

Временная сложность: 
O(log n)

Обоснование:
Экспоненциальное увеличение границы поиска: O(log n) шагов
Бинарный поиск в найденном диапазоне: O(log n)
Итого: O(log n) + O(log n) = O(log n)

Результат работы:
Массив: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
Ищем: 128
Индекс найденного элемента: 7


6)Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Принцип работы:
Делим отсортированный массив на три равные части
Сравниваем искомый элемент с граничными значениями
Определяем, в какой трети находится элемент
Рекурсивно повторяем для выбранной трети
Работает только для унимодальных функций

Временная сложность:
O(log₃n)

Обоснование:
На каждой итерации поисковое пространство уменьшается в 3 раза
Количество итераций: log₃n
На каждой итерации выполняется O(1) операций сравнения
В асимптотике: O(log₃n) = O(log n)
